{"version":3,"file":"static/js/221.23a45788.chunk.js","mappings":"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","sources":["logic/bitlogic/BitVector.ts","logic/bitlogic/LogicalExpression.ts","logic/bitlogic/BitLogic.ts","logic/booleanlogic/BooleanExpression.ts","tooltips/worker/Worker.ts","tooltips/worker/Utils.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["const ONE = BigInt(1);\r\nconst ZERO = BigInt(0);\r\n\r\nfunction intersection<T>(a: Set<T>, b: Set<T>): Set<T> {\r\n    if (a.size > b.size) {\r\n        const tmp = a;\r\n        // eslint-disable-next-line no-param-reassign\r\n        a = b;\r\n        // eslint-disable-next-line no-param-reassign\r\n        b = tmp;\r\n    }\r\n    return new Set([...a].filter((v) => b.has(v)));\r\n}\r\n\r\nfunction union<T>(a: Set<T>, b: Set<T>): Set<T> {\r\n    return new Set([...a, ...b]);\r\n}\r\n\r\n/**\r\n * A fixed-size bit vector.\r\n */\r\nexport class BitVector {\r\n    data: bigint;\r\n    intSet: Set<number>;\r\n\r\n    constructor();\r\n    constructor(bits: bigint, intSet: Set<number>);\r\n\r\n    constructor(bits?: bigint, intSet?: Set<number>) {\r\n        this.data = bits ?? ZERO;\r\n        this.intSet = intSet ?? new Set();\r\n    }\r\n\r\n    /** Sets the bit `bit` in this BitVector, if not already set. */\r\n    setBit(bit: number): this {\r\n        this.data |= ONE << BigInt(bit);\r\n        this.intSet.add(bit);\r\n        return this;\r\n    }\r\n\r\n    /** Clears the bit `bit` in this BitVector, if set. */\r\n    clearBit(bit: number): this {\r\n        if (this.intSet.has(bit)) {\r\n            this.data = this.data - (ONE << BigInt(bit));\r\n            this.intSet.delete(bit);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** Creates a new BitVector consisting of the bits that are both in `this` and `other`. */\r\n    and(other: BitVector) {\r\n        return new BitVector(other.data & this.data, intersection(other.intSet, this.intSet));\r\n    }\r\n\r\n    /** Creates a new BitVector consisting of the bits that are in `this` or in `other`. */\r\n    or(other: BitVector) {\r\n        return new BitVector(other.data | this.data, union(other.intSet, this.intSet));\r\n    }\r\n\r\n    /** Returns true iff `bit` is set in this BitVector. */\r\n    test(bit: number) {\r\n        return this.intSet.has(bit);\r\n    }\r\n\r\n    /** Returns true iff all the bits in `this` are also set in `other`. */\r\n    isSubsetOf(other: BitVector) {\r\n        return this.numSetBits <= other.numSetBits && (this.data | other.data) === other.data;\r\n    }\r\n\r\n    /** Returns true iff all the bits in `this` are also set in `other` and the other way around. */\r\n    equals(other: BitVector) {\r\n        return this.data === other.data;\r\n    }\r\n\r\n    /**\r\n     * slow\r\n     */\r\n    toString(domainSize: number) {\r\n        let str = \"\";\r\n        for (let bit = domainSize - 1; bit >= 0; bit--) {\r\n            if (this.data & (ONE << BigInt(bit))) {\r\n                str += '1';\r\n            } else {\r\n                str += '0';\r\n            }\r\n        }\r\n        return str;\r\n    }\r\n\r\n    /** Returns a new BitVector with exactly the same bits set. */\r\n    clone() {\r\n        return new BitVector(this.data, new Set(this.intSet));\r\n    }\r\n\r\n    /** Returns true iff no bits are set. */\r\n    isEmpty() {\r\n        return this.numSetBits === 0;\r\n    }\r\n\r\n    /** Returns true iff there is a bit that's set in both `this` and `other`. */\r\n    intersects(other: BitVector) {\r\n        return Boolean(this.data & other.data);\r\n    }\r\n\r\n    /** Iterates over all set bits in this BitVector. */\r\n    iter(): IterableIterator<number> {\r\n        return this.intSet.values()\r\n    }\r\n\r\n    /** Assuming that this vector has a single set bit, returns it. */\r\n    getSingleSetBit(): number {\r\n        return this.intSet.values().next().value as number\r\n    }\r\n\r\n    /** Returns the number of bits set in this BitVector. */\r\n    get numSetBits() {\r\n        return this.intSet.size\r\n    }\r\n}","import { BitVector } from './BitVector';\r\n\r\n/**\r\n * A logical expression in DNF (disjunctive normal form).\r\n */\r\nexport class LogicalExpression {\r\n    conjunctions: BitVector[];\r\n\r\n    /** Creates an expression that always evaluates to false. */\r\n    static false() {\r\n        return new LogicalExpression([]);\r\n    }\r\n\r\n    /** Creates an expression that always evaluates to true. */\r\n    static true() {\r\n        return new LogicalExpression([new BitVector()]);\r\n    }\r\n\r\n    /** Constructs an expression from the given BitVectors describing a DNF expression. */\r\n    constructor(conjs: BitVector[]) {\r\n        this.conjunctions = conjs;\r\n    }\r\n\r\n    /**\r\n     * Constructs an expression that evaluates to true if `this`\r\n     * evaluates to true or `other` evaluates to true.\r\n     */\r\n    or(other: LogicalExpression | BitVector) {\r\n        if (other instanceof BitVector) {\r\n            return new LogicalExpression([...this.conjunctions, other]);\r\n        } else {\r\n            return new LogicalExpression([\r\n                ...this.conjunctions,\r\n                ...other.conjunctions,\r\n            ]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructs an expression that evaluates to true if `this`\r\n     * evaluates to true and `other` evaluates to true.\r\n     */\r\n    and(other: LogicalExpression | BitVector) {\r\n        if (other instanceof BitVector) {\r\n            return new LogicalExpression(\r\n                andToDnf2(this.conjunctions, [other]),\r\n            );\r\n        }\r\n\r\n        if (this.isTriviallyFalse() || other.isTriviallyFalse()) {\r\n            return LogicalExpression.false();\r\n        }\r\n        return new LogicalExpression(\r\n            andToDnf2(this.conjunctions, other.conjunctions),\r\n        );\r\n    }\r\n\r\n    /**\r\n     * From each conjunction in the DNF, removes `drop` unless the\r\n     * `unless` bit is set.\r\n     */\r\n    drop_unless(drop: number, unless: number) {\r\n        return new LogicalExpression(\r\n            this.conjunctions.map((c) =>\r\n                c.test(unless) ? c : c.clone().clearBit(drop),\r\n            ),\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Simplifies the expression by removing disjuncts that are implied by a another disjunct.\r\n     */\r\n    removeDuplicates() {\r\n        const terms: BitVector[] = [];\r\n        for (let i = 0; i < this.conjunctions.length; i++) {\r\n            const candidate = this.conjunctions[i];\r\n            const weakerTerm = terms.findIndex((t) => t.isSubsetOf(candidate));\r\n            if (weakerTerm !== -1) {\r\n                continue;\r\n            }\r\n\r\n            const strongerTerm = terms.findIndex((t) =>\r\n                candidate.isSubsetOf(t),\r\n            );\r\n            if (strongerTerm !== -1) {\r\n                terms[strongerTerm] = candidate;\r\n            } else {\r\n                terms.push(candidate);\r\n            }\r\n        }\r\n        return new LogicalExpression(terms);\r\n    }\r\n\r\n    /**\r\n     * Evaluates the expression assuming the variables in `vec` are true.\r\n     */\r\n    eval(vec: BitVector) {\r\n        return this.conjunctions.some((c) => c.isSubsetOf(vec));\r\n    }\r\n\r\n    /**\r\n     * Whether the expression always definitely evaluates to false.\r\n     */\r\n    isTriviallyFalse() {\r\n        return this.conjunctions.length === 0;\r\n    }\r\n\r\n    /**\r\n     * Whether the expression always definitely evaluates to true.\r\n     */\r\n    isTriviallyTrue() {\r\n        return (\r\n            this.conjunctions.length > 0 &&\r\n            this.conjunctions.some((c) => c.isEmpty())\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * An optimized (unrolled) version of `andToDnf` for AND-ing exactly two expressions.\r\n */\r\nfunction andToDnf2(left: BitVector[], right: BitVector[]): BitVector[] {\r\n    const newExpr = [];\r\n    for (const l of left) {\r\n        for (const r of right) {\r\n            newExpr.push(l.or(r));\r\n        }\r\n    }\r\n    return newExpr;\r\n}\r\n\r\nexport function andToDnf(arr: BitVector[][]): BitVector[] {\r\n    if (arr.length === 2) {\r\n        return andToDnf2(arr[0], arr[1]);\r\n    }\r\n    const newExpr = [];\r\n    for (const tuple of cartesianProduct(...arr)) {\r\n        const newVec = tuple.reduce(\r\n            (acc, val) => acc.or(val),\r\n            new BitVector(),\r\n        );\r\n        newExpr.push(newVec);\r\n    }\r\n    return newExpr;\r\n}\r\n\r\nfunction cartesianProduct<T>(...allEntries: T[][]): T[][] {\r\n    return allEntries.reduce<T[][]>(\r\n        (results, entries) =>\r\n            results\r\n                .map((result) => entries.map((entry) => result.concat([entry])))\r\n                .reduce((subResults, result) => subResults.concat(result), []),\r\n        [[]],\r\n    );\r\n}\r\n","import { LogicalExpression } from './LogicalExpression';\r\nimport { BitVector } from './BitVector';\r\n\r\n/**\r\n * Requirements are a partial logic that makes statements about the present bits\r\n * and no statements about absent bits.\r\n */\r\nexport type Requirements = Record<number, LogicalExpression>;\r\n/**\r\n * A BitLogic models a least fixed-point logic (LFP).\r\n * Since every LogicalExpression can only mention terms positively\r\n * (no negation, no quantifiers) this least fixed-point always exists.\r\n */\r\nexport type BitLogic = LogicalExpression[];\r\n\r\nexport function mergeRequirements(numBits: number, ...reqs: Requirements[]): BitLogic {\r\n    const requirements: LogicalExpression[] = [];\r\n    const mergedRequirements: Requirements = {};\r\n    Object.assign(mergedRequirements, ...reqs);\r\n    for (let i = 0; i < numBits; i++) {\r\n        requirements.push(mergedRequirements[i] ?? LogicalExpression.false());\r\n    }\r\n    return requirements;\r\n}\r\n\r\n\r\n/* \r\n * Returns the least fixed-point of the given requirements,\r\n * which can be interpreted as the logical result of the given requirements.\r\n * This is a BitVector from which no new facts can be derived.\r\n */\r\nexport function computeLeastFixedPoint(\r\n    /** Why is this being computed? For logging */\r\n    reason: string,\r\n    /** The BitLogic describing the logic program (requirements). */\r\n    logic: BitLogic,\r\n    /**\r\n     * To resume computation from an earlier result after adding facts to `additionalRequirements`\r\n     * (concretely: semilogic requirements), pass startingBits. Purely a performance optimization.\r\n     */\r\n    startingBits?: BitVector,\r\n) {\r\n    // This is an extremely simple iterate-to-fixpoint solver in O(n^2).\r\n    // There are better algorithms but this usually converges after\r\n    // about 15 rounds.\r\n    const bits = startingBits?.clone() ?? new BitVector();\r\n    let changed = true;\r\n    let iterations = 0;\r\n    const start = performance.now();\r\n    while (changed) {\r\n        changed = false;\r\n        for (const [idx, expr] of logic.entries()) {\r\n            const evaluate = (e: LogicalExpression) => {\r\n                const val = e.eval(bits);\r\n                if (val) {\r\n                    bits.setBit(idx);\r\n                    return true;\r\n                }\r\n                return false;\r\n            };\r\n\r\n            if (expr.isTriviallyFalse()) {\r\n                continue;\r\n            } else if (!bits.test(idx)) {\r\n                const didChange = evaluate(expr);\r\n                changed ||= didChange;\r\n            }\r\n        }\r\n        iterations++;\r\n    }\r\n    console.log(\r\n        reason,\r\n        'fixpoint iteration took',\r\n        performance.now() - start,\r\n        'ms for',\r\n        iterations,\r\n        'iterations',\r\n    );\r\n\r\n    return bits;\r\n}\r\n\r\n/**\r\n * Some requirements still have some relatively deep expressions, and the `computeGroundExpression` algorithm may perform poorly\r\n * if it repeately has to reveal a complex entrance. Finding *any* path to the check has a reasonably likelyhood\r\n * of including these bottlenecks, and precomputing bits in that partial path can solve a lot of problems and the\r\n * results can even be reused.\r\n */\r\nexport function findNewSubgoals(\r\n    /** Do not reveal these bits */\r\n    opaqueBits: BitVector,\r\n    /** Traverse these requirements... */\r\n    requirements: LogicalExpression[],\r\n    /** ...starting from here. */\r\n    idx: number,\r\n    /**\r\n     * Expressions we've already precomputed\r\n     * in a previous run, used to reveal new paths\r\n     * and stop searching if there aren't any paths remaining.\r\n     */\r\n    learnedExpressions: Set<number>,\r\n    visitedExpressions: Set<number> = new Set(),\r\n): BitVector | undefined {\r\n    if (visitedExpressions.has(idx)) {\r\n        return undefined;\r\n    }\r\n    const expr = requirements[idx];\r\n    if (expr.isTriviallyFalse()) {\r\n        return undefined;\r\n    }\r\n\r\n    if (learnedExpressions.has(idx)) {\r\n        return undefined;\r\n    }\r\n\r\n    visitedExpressions.add(idx);\r\n\r\n    for (const conj of requirements[idx].conjunctions) {\r\n        for (const bit of conj.iter()) {\r\n            if (!opaqueBits.test(bit) && !learnedExpressions.has(bit)) {\r\n                const moreBits = findNewSubgoals(\r\n                    opaqueBits,\r\n                    requirements,\r\n                    bit,\r\n                    learnedExpressions,\r\n                    visitedExpressions,\r\n                );\r\n                if (moreBits) {\r\n                    return new BitVector()\r\n                        .setBit(bit)\r\n                        .or(moreBits);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    visitedExpressions.delete(idx);\r\n    return new BitVector();\r\n}\r\n\r\n/**\r\n * Convert the expression at `idx` to a first-order logic expression\r\n * that is only based on the ground terms `opaqueBits` - in other words,\r\n * create a closed formula for the potentially (self- and nested-)recursive\r\n * expression at `idx`.\r\n */\r\nexport function computeGroundExpression(\r\n    opaqueBits: BitVector,\r\n    requirements: LogicalExpression[],\r\n    idx: number,\r\n    visitedExpressions: Set<number> = new Set(),\r\n): LogicalExpression {\r\n    let result = LogicalExpression.false();\r\n    if (visitedExpressions.has(idx)) {\r\n        return result;\r\n    }\r\n    visitedExpressions.add(idx);\r\n\r\n    // TODO this is a standard BRANCH algorithm but we don't have a BOUND.\r\n    // It'd be useful to know when we've found the minimum requirements and\r\n    // when exploring additional paths wouldn't help.\r\n\r\n    // TODO even with a BOUND this may not be the best solution. In practice this\r\n    // works for some requirements, is fairly slow for others, and fails catastrophically\r\n    // for a few unless some specific subgoals are evaluated first (see `findNewSubgoals`).\r\n    // So if you see the tooltips task getting stuck, it's likely here and because `findNewSubgoals`\r\n    // didn't make us learn an important expression.\r\n    // Some alternatives:\r\n    // * Not output a DNF but a multi-level form. This however needs tooltips to implement\r\n    //   more sophisticated simplification algorithms.\r\n    // * Convert the requirements to a proper directed graph structure first, where things like\r\n    //   degree and \"bottlenecks\" are known, then use better heuristics there.\r\n    // * Find a All-SAT solver that can deal with fixed-point logic.\r\n    //   Good luck with that, SAT solvers need input in CNF, All-SAT solvers seem to\r\n    //   only exist in theory, and cycles are not considered.\r\n\r\n    nextConj: for (const conj of requirements[idx].conjunctions) {\r\n        let tmpExpr = LogicalExpression.true();\r\n        const conjOpaqueBits = opaqueBits.and(conj);\r\n        for (const bit of conj.iter()) {\r\n            if (!conjOpaqueBits.test(bit)) {\r\n                const newTerm = computeGroundExpression(\r\n                    opaqueBits,\r\n                    requirements,\r\n                    bit,\r\n                    visitedExpressions,\r\n                );\r\n                if (newTerm.isTriviallyFalse()) {\r\n                    continue nextConj;\r\n                }\r\n                tmpExpr = tmpExpr.and(newTerm).removeDuplicates();\r\n            }\r\n        }\r\n        if (conjOpaqueBits.numSetBits) {\r\n            tmpExpr = tmpExpr.and(conjOpaqueBits);\r\n        }\r\n\r\n        result = result.or(tmpExpr);\r\n    }\r\n\r\n    visitedExpressions.delete(idx);\r\n    return result.removeDuplicates();\r\n}\r\n\r\nexport function removeDuplicates(logic: BitLogic) {\r\n    for (const [idx, expr] of logic.entries()) {\r\n        if (expr.conjunctions.length >= 2) {\r\n            logic[idx] = expr.removeDuplicates();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Unifies non-opaque requirements if they directly imply each other. This is mostly\r\n * for simplifying clusters like the Sky, where there are lots of areas that are\r\n * all equally accessible as long as you're somewhere in the sky. This means one of\r\n * the unified areas will only have a single bit requirement, which can be inlined later.\r\n *\r\n * Returns true iff any simplifications have been made.\r\n */\r\nexport function unifyRequirements(\r\n    opaqueBits: BitVector,\r\n    requirements: LogicalExpression[],\r\n) {\r\n    // First, an O(n) scan to rule out expressions that are definitely not eligible\r\n    const unificationCandidates: number[][] = requirements.map(() => []);\r\n    for (const [idx, expr] of requirements.entries()) {\r\n        if (opaqueBits.test(idx)) {\r\n            continue;\r\n        }\r\n        for (const conj of expr.conjunctions) {\r\n            if (conj.numSetBits === 1) {\r\n                const bit = conj.getSingleSetBit();\r\n                if (bit === idx || opaqueBits.test(bit)) {\r\n                    continue;\r\n                }\r\n                (unificationCandidates[bit]).push(idx);\r\n            }\r\n        }\r\n    }\r\n\r\n    let simplified = false;\r\n    for (let a = 0; a < requirements.length; a++) {\r\n        const targetList = unificationCandidates[a];\r\n        for (const b of targetList) {\r\n            if (tryUnifyEquivalent(requirements, a, b)) {\r\n                simplified = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    return simplified;\r\n}\r\n\r\n/**\r\n * Check if:\r\n *  z <= a\r\n *  a <= b | x\r\n *  b <= a | y\r\n * Rewrite to:\r\n *  z <= a\r\n *  a <= b,\r\n *  b <= x | y,\r\n * This breaks a cycle between `a` and `b`, and any dependencies on `a`\r\n * can be rewritten to depend on `b` in a later shallowSimplify call.\r\n */\r\nfunction tryUnifyEquivalent(requirements: LogicalExpression[], a: number, b: number) {\r\n    const implA = requirements[a];\r\n    const implB = requirements[b];\r\n\r\n    if (implA.conjunctions.length < 2 || implB.conjunctions.length < 2) {\r\n        return false;\r\n    }\r\n\r\n    const bImpliesAIndex = implA.conjunctions.findIndex(\r\n        (cA) => cA.numSetBits === 1 && cA.test(b),\r\n    );\r\n    if (bImpliesAIndex === -1) {\r\n        return false;\r\n    }\r\n\r\n    const aImpliesBIndex = implB.conjunctions.findIndex(\r\n        (cB) => cB.numSetBits === 1 && cB.test(a),\r\n    );\r\n    if (aImpliesBIndex === -1) {\r\n        return false;\r\n    }\r\n\r\n    // Copy reqs from a to b\r\n    const implACon = implA.conjunctions.slice();\r\n    const bReqVec = implACon.splice(bImpliesAIndex, 1);\r\n    for (const cn of implACon) {\r\n        requirements[b] = requirements[b].or(cn);\r\n    }\r\n    requirements[a] = new LogicalExpression(bReqVec);\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Shallow simplification \"inlines\" non-opaque requirements that themselves only consist\r\n * of at most one conjunction into upstream conjunctions. A DNF requirement with zero\r\n * conjunctions is always False, so any conjunctions it appears in can be dropped,\r\n * while a DNF with exactly one conjunction can be inlined.\r\n *\r\n * Returns true iff any simplifications could be made.\r\n * \r\n * \r\n * E.g:\r\n *   a <= b&c | f | d\r\n *   b <= <false>\r\n *   d <= e\r\n *   f <= g&h\r\n * Rewrite to:\r\n *   a <= g&h | e\r\n *   b <= <false>\r\n *   d <= e\r\n *   f <= g&h\r\n */\r\nexport function shallowSimplify(\r\n    opaqueBits: BitVector,\r\n    requirements: BitLogic,\r\n) {\r\n    const inliningCandidates = new BitVector();\r\n\r\n    let simplified = false;\r\n\r\n    for (let item = 0; item < requirements.length; item++) {\r\n        if (\r\n            !opaqueBits.test(item) &&\r\n            requirements[item].conjunctions.length <= 1\r\n        ) {\r\n            inliningCandidates.setBit(item);\r\n        }\r\n    }\r\n\r\n    for (const [idx, expr] of requirements.entries()) {\r\n        if (expr.conjunctions.length >= 30 || opaqueBits.test(idx)) {\r\n            continue;\r\n        }\r\n        let newExpr = LogicalExpression.false();\r\n        for (const conj of expr.conjunctions) {\r\n            if (conj.intersects(inliningCandidates)) {\r\n                simplified = true;\r\n                let newItems = new BitVector();\r\n                let skip = false;\r\n                for (const reqItem of conj.iter()) {\r\n                    if (!inliningCandidates.test(reqItem)) {\r\n                        newItems.setBit(reqItem);\r\n                    } else {\r\n                        const revealed = requirements[reqItem];\r\n\r\n                        if (revealed.isTriviallyTrue()) {\r\n                            continue;\r\n                        }\r\n\r\n                        if (revealed.isTriviallyFalse()) {\r\n                            skip = true;\r\n                            break;\r\n                        }\r\n                        newItems = newItems.or(revealed.conjunctions[0]);\r\n                    }\r\n                }\r\n                if (!skip && !newItems.test(idx)) {\r\n                    newExpr = newExpr.or(newItems);\r\n                }\r\n            } else {\r\n                newExpr = newExpr.or(conj);\r\n            }\r\n        }\r\n\r\n        requirements[idx] = newExpr;\r\n    }\r\n    return simplified;\r\n}\r\n","import _ from 'lodash';\r\n\r\nexport enum Op {\r\n    And = 'and',\r\n    Or = 'or',\r\n}\r\n\r\nexport type Item = BooleanExpression | string;\r\ntype BinOp<T> = (left: T, right: T) => boolean;\r\ntype ParentItems = {\r\n    [op in Op]: Item[]\r\n}\r\n\r\nexport type ReducerArg<T> = { isReduced: true, accumulator: T, item: T } | { isReduced: false, accumulator: T, item: string };\r\ntype Reducer<T> = (arg: ReducerArg<T>) => T;\r\ntype Reducers<T> = {\r\n    andInitialValue: T,\r\n    orInitialValue: T,\r\n    andReducer: Reducer<T>,\r\n    orReducer: Reducer<T>,\r\n}\r\n\r\nexport class BooleanExpression {\r\n    type: Op;\r\n    items: Item[];\r\n\r\n    constructor(items: Item[], type: Op) {\r\n        this.items = items;\r\n        this.type = type;\r\n    }\r\n\r\n    static and(...items: Item[]) {\r\n        return new BooleanExpression(items, Op.And);\r\n    }\r\n\r\n    static or(...items: Item[]) {\r\n        return new BooleanExpression(items, Op.Or);\r\n    }\r\n\r\n    isAnd() {\r\n        return this.type === Op.And;\r\n    }\r\n\r\n    isOr() {\r\n        return this.type === Op.Or;\r\n    }\r\n\r\n    reduce<T>({\r\n        andInitialValue,\r\n        andReducer,\r\n        orInitialValue,\r\n        orReducer,\r\n    }: Reducers<T>): T {\r\n        const reducerArguments = (accumulator: T, item: Item): ReducerArg<T> => {\r\n            if (BooleanExpression.isExpression(item)) {\r\n                const reducedItem = item.reduce({\r\n                    andInitialValue,\r\n                    andReducer,\r\n                    orInitialValue,\r\n                    orReducer,\r\n                });\r\n\r\n                return {\r\n                    accumulator,\r\n                    item: reducedItem,\r\n                    isReduced: true,\r\n                };\r\n            }\r\n            return {\r\n                accumulator,\r\n                item,\r\n                isReduced: false,\r\n            };\r\n        };\r\n\r\n        if (this.isAnd()) {\r\n            return _.reduce(\r\n                this.items,\r\n                (acc, item) => andReducer(\r\n                    reducerArguments(acc, item),\r\n                ),\r\n                andInitialValue,\r\n            );\r\n        }\r\n\r\n        if (this.isOr()) {\r\n            return _.reduce(\r\n                this.items,\r\n                (acc, item) => orReducer(\r\n                    reducerArguments(acc, item),\r\n                ),\r\n                orInitialValue,\r\n            );\r\n        }\r\n        throw Error(`Invalid type: ${this.type}`);\r\n    }\r\n\r\n    evaluate(isItemTrue: (item: string) => boolean) {\r\n        return this.reduce({\r\n            andInitialValue: true,\r\n            andReducer: ({ accumulator, item, isReduced }) => accumulator && (isReduced ? item : isItemTrue(item)),\r\n            orInitialValue: false,\r\n            orReducer: ({ accumulator, item, isReduced }) => accumulator || (isReduced ? item : isItemTrue(item)),\r\n        });\r\n    }\r\n\r\n    simplify(implies: BinOp<string>, iterations = 3) {\r\n        let updatedExpression = this.flatten();\r\n\r\n        for (let i = 0; i < iterations; i++) {\r\n            updatedExpression = updatedExpression.removeDuplicateChildren(implies);\r\n            updatedExpression = updatedExpression.removeDuplicateExpressions(implies);\r\n            updatedExpression = updatedExpression.shiftWeakerTermsUp(implies);\r\n        }\r\n\r\n        return updatedExpression;\r\n    }\r\n\r\n    oppositeType() {\r\n        if (this.isAnd()) {\r\n            return Op.Or;\r\n        }\r\n        if (this.isOr()) {\r\n            return Op.And;\r\n        }\r\n        throw Error(`Invalid type for boolean expression: ${this.type}`);\r\n    }\r\n\r\n    static isExpression(item: unknown): item is BooleanExpression {\r\n        return typeof item === 'object' && item instanceof BooleanExpression;\r\n    }\r\n\r\n    isEqualTo(otherExpression: Item, areItemsEqual: BinOp<string>): boolean {\r\n        if (!BooleanExpression.isExpression(otherExpression) || this.type !== otherExpression.type || this.items.length !== otherExpression.items.length) {\r\n            return false;\r\n        }\r\n\r\n        const difference = _.xorWith(this.items, otherExpression.items, (item, otherItem) => {\r\n            if (BooleanExpression.isExpression(item)) {\r\n                return item.isEqualTo(otherItem, areItemsEqual);\r\n            }\r\n            // if one item is not an expression and the other is not then they cannot be equal\r\n            if (BooleanExpression.isExpression(otherItem)) {\r\n                return false;\r\n            }\r\n            return areItemsEqual(item, otherItem);\r\n        });\r\n        return _.isEmpty(difference);\r\n    }\r\n\r\n    flatten(): BooleanExpression {\r\n        const newItems = this.items.flatMap((item) => {\r\n            if (!BooleanExpression.isExpression(item)) {\r\n                return item;\r\n            }\r\n            const flatItem = item.flatten();\r\n            if (_.isEmpty(flatItem.items)) {\r\n                return [];\r\n            }\r\n            if (flatItem.type === this.type || flatItem.items.length === 1) {\r\n                return flatItem.items;\r\n            }\r\n            return flatItem;\r\n        });\r\n\r\n        if (newItems.length === 1) {\r\n            const firstItem = _.first(newItems);\r\n            if (BooleanExpression.isExpression(firstItem)) {\r\n                return firstItem;\r\n            }\r\n        }\r\n\r\n        return new BooleanExpression(newItems, this.type);\r\n    }\r\n\r\n    static createFlatExpression(items: Item[], type: Op) {\r\n        return new BooleanExpression(items, type).flatten();\r\n    }\r\n\r\n    // determines if a provided item is subsumed by a provided collection of items\r\n    // calculation depends on the type of the containing expression\r\n    // implies is the function for determing if requirements are subsumable (defines the relationship between items)\r\n    static itemIsSubsumed(itemsCollection: Item[], item: string, expressionType: Op, implies: BinOp<string>) {\r\n        let itemIsSubsumed = false;\r\n        itemsCollection.forEach((otherItem) => {\r\n            if (this.isExpression(otherItem)) {\r\n                return true;\r\n            }\r\n\r\n            switch (expressionType) {\r\n                case Op.And: {\r\n                    // for and logic the subsuming item (the item from the collection) needs to imply the subsumed item\r\n                    // otherwise the logic would lose precision on counted items (i.e. Sword x2 could subsume Sword x3 depending on sequence)\r\n                    if (implies(otherItem, item)) {\r\n                        itemIsSubsumed = true;\r\n                        return false;\r\n                    }\r\n                    break;\r\n                }\r\n                case Op.Or: {\r\n                    // for an or expression this precision doesn't matter - Sword x2 is just as good as Sword x3, therefore any implying\r\n                    // item can subsume the item in question\r\n                    if (implies(item, otherItem)) {\r\n                        itemIsSubsumed = true;\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        });\r\n        return itemIsSubsumed;\r\n    }\r\n\r\n    getUpdatedParentItems(parentItems: ParentItems) {\r\n        return _.mergeWith({}, parentItems, { [this.type]: this.items }, (objectValue: Item[], sourceValue: Item[]) => {\r\n            if (_.isArray(objectValue)) {\r\n                return _.concat(objectValue, _.filter(sourceValue, (value) => !BooleanExpression.isExpression(value)));\r\n            }\r\n            return undefined;\r\n        });\r\n    }\r\n\r\n    removeDuplicateChildrenHelper(implies: BinOp<string>, parentItems: ParentItems) {\r\n        const newItems: Item[] = [];\r\n        const updatedParentItems = this.getUpdatedParentItems(parentItems);\r\n        const sameTypeItems = _.get(parentItems, this.type);\r\n        const oppositeTypeItems = _.get(parentItems, this.oppositeType());\r\n        let removeSelf = false;\r\n\r\n        this.items.forEach((item) => {\r\n            if (BooleanExpression.isExpression(item)) {\r\n                const {\r\n                    expression: childExpression,\r\n                    removeParent: childRemoveParent,\r\n                } = item.removeDuplicateChildrenHelper(implies, updatedParentItems);\r\n\r\n                if (childRemoveParent) {\r\n                    removeSelf = true;\r\n                    return false;\r\n                }\r\n                newItems.push(childExpression);\r\n            } else {\r\n                if (BooleanExpression.itemIsSubsumed(oppositeTypeItems, item, this.oppositeType(), implies)) {\r\n                    removeSelf = true;\r\n                    return false;\r\n                }\r\n\r\n                if (!BooleanExpression.itemIsSubsumed(sameTypeItems, item, this.type, implies)) {\r\n                    newItems.push(item);\r\n                }\r\n            }\r\n            return true;\r\n        });\r\n\r\n        if (removeSelf) {\r\n            return {\r\n                expression: BooleanExpression.and(),\r\n                removeParent: false,\r\n            };\r\n        }\r\n\r\n        const expression = BooleanExpression.createFlatExpression(newItems, this.type);\r\n        if (_.isEmpty(expression.items)) {\r\n            return {\r\n                expression: BooleanExpression.and(),\r\n                removeParent: true,\r\n            };\r\n        }\r\n\r\n        return {\r\n            expression,\r\n            removeParent: false,\r\n        };\r\n    }\r\n\r\n    removeDuplicateChildren(implies: BinOp<string>) {\r\n        const { expression } = this.removeDuplicateChildrenHelper(implies, {\r\n            [Op.And]: [],\r\n            [Op.Or]: [],\r\n        });\r\n        return expression;\r\n    }\r\n\r\n    isSubsumedBy(otherExpression: BooleanExpression, implies: BinOp<string>, removeIfIdentical: boolean, expressionType: Op): boolean {\r\n        if (this.isEqualTo(otherExpression, (item, otherItem) => implies(item, otherItem) && implies(otherItem, item))) {\r\n            return removeIfIdentical;\r\n        }\r\n        return otherExpression.items.every((otherItem) => {\r\n            if (BooleanExpression.isExpression(otherItem)) {\r\n                return this.isSubsumedBy(otherItem, implies, true, expressionType);\r\n            }\r\n            return BooleanExpression.itemIsSubsumed(this.items, otherItem, expressionType, implies);\r\n        });\r\n    }\r\n\r\n    expressionIsSubsumed(expression: BooleanExpression, index: number, implies: BinOp<string>) {\r\n        let expressionIsSubsumed = false;\r\n        this.items.forEach((otherItem, otherIndex) => {\r\n            if (otherIndex === index) {\r\n                return true;\r\n            }\r\n\r\n            let otherExpression: BooleanExpression;\r\n            if (BooleanExpression.isExpression(otherItem)) {\r\n                otherExpression = otherItem;\r\n            } else {\r\n                otherExpression = BooleanExpression.and(otherItem);\r\n            }\r\n\r\n            const isSubsumed = expression.isSubsumedBy(otherExpression, implies, otherIndex < index, this.oppositeType());\r\n            if (isSubsumed) {\r\n                expressionIsSubsumed = true;\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n        return expressionIsSubsumed;\r\n    }\r\n\r\n    removeDuplicateExpressionsInChildren(implies: BinOp<string>): BooleanExpression {\r\n        const newItems = this.items.map((item) => {\r\n            if (BooleanExpression.isExpression(item)) {\r\n                return item.removeDuplicateExpressions(implies);\r\n            }\r\n            return item;\r\n        });\r\n        return BooleanExpression.createFlatExpression(newItems, this.type);\r\n    }\r\n\r\n    removeDuplicateExpressions(implies: BinOp<string>): BooleanExpression {\r\n        const parentExpression = this.removeDuplicateExpressionsInChildren(implies);\r\n        const newItems = parentExpression.items.filter((item, index) => {\r\n            let expression;\r\n            if (BooleanExpression.isExpression(item)) {\r\n                expression = item;\r\n            } else {\r\n                expression = BooleanExpression.and(item);\r\n            }\r\n\r\n            return !parentExpression.expressionIsSubsumed(expression, index, implies);\r\n        });\r\n\r\n        if (this.type === Op.Or && newItems.length >= 2 && _.every(_.map(newItems, BooleanExpression.isExpression))) {\r\n            const commonFactors: Item[] = [];\r\n            const booleanItems = newItems as BooleanExpression[];\r\n            _.forEach(booleanItems[0].items, (item) => {\r\n                if (_.every(_.map(booleanItems, (expr) => _.includes(expr.items, item)))) {\r\n                    commonFactors.push(item);\r\n                }\r\n            });\r\n            if (commonFactors.length) {\r\n                return new BooleanExpression([...commonFactors, new BooleanExpression([...(newItems.filter((item) => !commonFactors.includes(item)))], this.type)], this.oppositeType());\r\n            }\r\n        }\r\n        return BooleanExpression.createFlatExpression(newItems, this.type);\r\n    }\r\n\r\n    shiftWeakerTermsUp(implies: BinOp<string>): BooleanExpression {\r\n        const parentExpression = this.removeDuplicateExpressionsInChildren(implies);\r\n        if (parentExpression.isOr() && parentExpression.items.every((i) => !BooleanExpression.isExpression(i) || i.isAnd())) {\r\n            for (const item of parentExpression.items) {\r\n                if (!BooleanExpression.isExpression(item)) {\r\n                    continue;\r\n                }\r\n                for (const subItem of item.items) {\r\n                    if (BooleanExpression.isExpression(subItem) && parentExpression.items.every((otherItem, index) => (otherItem as BooleanExpression).expressionIsSubsumed(subItem, index, implies))) {\r\n                        console.log('blub')\r\n                        return BooleanExpression.and(subItem, BooleanExpression.or(...parentExpression.items, ));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return parentExpression;\r\n    }\r\n}\r\n\r\nexport default BooleanExpression;\r\n","import _ from 'lodash';\r\nimport {\r\n    computeGroundExpression,\r\n    findNewSubgoals,\r\n    removeDuplicates,\r\n    shallowSimplify,\r\n    unifyRequirements,\r\n} from '../../logic/bitlogic/BitLogic';\r\nimport { BitVector } from '../../logic/bitlogic/BitVector';\r\nimport { LogicalExpression } from '../../logic/bitlogic/LogicalExpression';\r\nimport {\r\n    deserializeLogicalExpression,\r\n    serializeBooleanExpression,\r\n} from './Utils';\r\nimport { LeanLogic, WorkerRequest, WorkerResponse } from './Types';\r\nimport BooleanExpression, {\r\n    Item,\r\n} from '../../logic/booleanlogic/BooleanExpression';\r\n\r\n/**\r\n * This module contains various strategies to turn the requirements into a more compact and readable\r\n * form, with the goal of creating readable and understandable requirements for tooltips.\r\n */\r\n\r\n/**\r\n * Global application state. Will be initialized with the first message.\r\n */\r\ninterface GlobalState {\r\n    logic: LeanLogic;\r\n    opaqueBits: BitVector;\r\n    learned: Set<number>;\r\n    requirements: LogicalExpression[];\r\n}\r\n\r\nlet g: GlobalState;\r\n\r\nconsole.log('Hello from worker!');\r\n\r\nonmessage = (ev: MessageEvent<WorkerRequest>) => {\r\n    const start = performance.now();\r\n    switch (ev.data.type) {\r\n        case 'initialize': {\r\n            const opaqueBits = new BitVector();\r\n            for (const bit of ev.data.opaqueBits) {\r\n                opaqueBits.setBit(bit);\r\n            }\r\n            g = {\r\n                logic: ev.data.logic,\r\n                opaqueBits,\r\n                learned: new Set(),\r\n                requirements: ev.data.requirements.map(\r\n                    deserializeLogicalExpression,\r\n                ),\r\n            };\r\n\r\n            do {\r\n                // First, perform some cheap optimizations that will help every\r\n                // query afterwards.\r\n                removeDuplicates(g.requirements);\r\n                while (shallowSimplify(g.opaqueBits, g.requirements)) {\r\n                    removeDuplicates(g.requirements);\r\n                }\r\n            } while (unifyRequirements(g.opaqueBits, g.requirements));\r\n            console.log('worker', 'initializing and pre-simplifying took', performance.now() - start, 'ms');\r\n            break;\r\n        }\r\n        case 'analyze': {\r\n            if (!g) {\r\n                throw new Error('needs to be initialized first!!!!');\r\n            }\r\n            const expr = analyze(ev.data.checkId);\r\n            console.log('worker', 'total time for', ev.data.checkId, 'was', performance.now() - start, 'ms');\r\n            postMessage({\r\n                checkId: ev.data.checkId,\r\n                expression: serializeBooleanExpression(expr),\r\n            } satisfies WorkerResponse);\r\n        }\r\n    }\r\n};\r\n\r\nfunction analyze(checkId: string): BooleanExpression {\r\n    const bit = g.logic.itemBits[checkId];\r\n\r\n    // We precompute (\"learn\") some subgoals because it improves performance.\r\n    // However, we can sometimes end up precomputing trivial requirements\r\n    // like \\Distance Activator for X Rupee items while expensive requirements\r\n    // like \\Can Medium Rupee Farm end up being not \"learned\" yet. So\r\n    // we always perform a minimum amount of work per item.\r\n    let numLearnedInPrecomputation = 0;\r\n    while (numLearnedInPrecomputation < 5) {\r\n        const potentialPath = findNewSubgoals(\r\n            g.opaqueBits,\r\n            g.requirements,\r\n            bit,\r\n            g.learned,\r\n        );\r\n\r\n        if (potentialPath && !potentialPath.isEmpty()) {\r\n            for (const precomputeBit of potentialPath.iter()) {\r\n                if (\r\n                    !g.opaqueBits.test(precomputeBit) &&\r\n                    !g.learned.has(precomputeBit)\r\n                ) {\r\n                    // And then precompute some non-opaque requirements. This persists between tooltips, so\r\n                    // different checks can reuse these results.\r\n                    // Note that even though the result of `findNewSubgoals` is obviously path-dependent and depends on the check in question,\r\n                    // this particular call happens in isolation and has no dependencies on the check in question, so reusing is sound!\r\n                    const start = performance.now();\r\n                    g.requirements[precomputeBit] = computeGroundExpression(\r\n                        g.opaqueBits,\r\n                        g.requirements,\r\n                        precomputeBit,\r\n                    );\r\n                    console.log('  ', 'worker', 'precomputing', g.logic.allItems[precomputeBit], 'took', performance.now() - start, 'ms');\r\n                    g.learned.add(precomputeBit);\r\n                    numLearnedInPrecomputation += 1;\r\n                }\r\n            }\r\n        } else {\r\n            // There are no subgoals to learn, so we can go straight to computing the goal.\r\n            break;\r\n        }\r\n    }\r\n\r\n    const start = performance.now();\r\n    const opaqueOnlyExpr = computeGroundExpression(\r\n        g.opaqueBits,\r\n        g.requirements,\r\n        bit,\r\n    );\r\n    console.log('  ', 'worker', 'computing', g.logic.allItems[bit], 'took', performance.now() - start, 'ms');\r\n    g.requirements[bit] = opaqueOnlyExpr;\r\n\r\n    const simplifyStart = performance.now();\r\n    const simplified = dnfToRequirementExpr(g.logic, opaqueOnlyExpr.conjunctions);\r\n    console.log('  ', 'worker', 'simplifying took', performance.now() - simplifyStart, 'ms');\r\n    return simplified;\r\n}\r\n\r\nfunction simplifier(logic: LeanLogic) {\r\n    return (a: string, b: string) => {\r\n        return a === b || Boolean(logic.dominators[b]?.includes(a));\r\n    };\r\n}\r\n\r\n/**\r\n * Converts a DNF to a readable requirements expression.\r\n *\r\n * Our DNF is a sum of products (SOP) with no negations and no don't-cares.\r\n * As a result, standard two-level simplification algorithms (Quine-McCluskey/Karnaugh Maps)\r\n * will not produce any simplifications.\r\n *\r\n * Instead, we are doing multi-level simplification as described in:\r\n * https://faculty.sist.shanghaitech.edu.cn/faculty/zhoupq/Teaching/Spr16/07-Multi-Level-Logic-Synthesis.pdf\r\n * https://www2.eecs.berkeley.edu/Pubs/TechRpts/1989/ERL-89-49.pdf (pp. 41-70)\r\n * We first remove all factors, and then treat the rest SOP as an algebraic expression.\r\n * Algebraic expressions don't know about special boolean rules (like a && !a = 0, a || !a = 1)\r\n * but since we don't have any don't cares and negations they will never be relevant.\r\n */\r\nexport function dnfToRequirementExpr(\r\n    logic: LeanLogic,\r\n    sop: BitVector[],\r\n): BooleanExpression {\r\n    if (sop.length === 0) {\r\n        return BooleanExpression.or();\r\n    }\r\n\r\n    if (sop.length === 1 && sop[0].isEmpty()) {\r\n        return BooleanExpression.and();\r\n    }\r\n\r\n    /*\r\n    return BooleanExpression.or(\r\n        ...sop.map((s) =>\r\n            BooleanExpression.and(\r\n                ...[...s.iter()].map((bit) => logic.allItems[bit]),\r\n            ),\r\n        ),\r\n    );\r\n    */\r\n\r\n    if (sop.length === 1) {\r\n        return BooleanExpression.and(\r\n            ...[...sop[0].iter()].map((x) => logic.allItems[x]),\r\n        ).simplify(simplifier(logic));\r\n    }\r\n\r\n    const conjunctions = new LogicalExpression(sop).removeDuplicates()\r\n        .conjunctions;\r\n\r\n    // After removing duplicates, remove dominated stuff from our terms so that\r\n    // simplification doesn't get funny ideas like pulling out irrelevant terms\r\n    // that we later can't easily simplify in a multi level form.\r\n    for (const conj of conjunctions) {\r\n        for (const bit of [...conj.iter()]) {\r\n            for (const dominator of logic.dominators[logic.allItems[bit]] ?? []) {\r\n                const dominatorBit = logic.itemBits[dominator];\r\n                if (dominatorBit !== bit && conj.test(dominatorBit)) {\r\n                    conj.clearBit(bit);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // First, remove all common factors and from our SOP so that it's \"cube-free\".\r\n    // This is a requirement for the algorithm to work, as per the presentation.\r\n    let commonFactors = new Set<number>(conjunctions[0].iter());\r\n    for (const conj of conjunctions) {\r\n        commonFactors = new Set(\r\n            // eslint-disable-next-line no-loop-func\r\n            [...conj.iter()].filter((b) => commonFactors.has(b)),\r\n        );\r\n    }\r\n\r\n    // Build a list of all variables mentioned in this expression.\r\n    const variables = new Set<number>();\r\n\r\n    for (const conj of conjunctions) {\r\n        for (const bit of commonFactors) {\r\n            conj.clearBit(bit);\r\n        }\r\n        for (const bit of conj.iter()) {\r\n            variables.add(bit);\r\n        }\r\n    }\r\n\r\n    // At this point it's best to just consult the lecture presentation for why this is happening.\r\n    const kernels = findKernels(\r\n        conjunctions,\r\n        [...variables],\r\n        new BitVector(),\r\n    ).filter((k) => !k.coKernel.isEmpty());\r\n\r\n    // Columns are all unique cubes in all kernels\r\n    const columns = kernels.reduce<BitVector[]>((acc, kernel) => {\r\n        for (const kCube of kernel.kernel) {\r\n            if (!acc.some((cube) => kCube.equals(cube))) {\r\n                acc.push(kCube);\r\n            }\r\n        }\r\n        return acc;\r\n    }, []);\r\n\r\n    // Rows are labelled with all unique co-kernels.\r\n    const rows = kernels;\r\n\r\n    if (rows.length > 0 && columns.length > 0) {\r\n        // Create a matrix with ones in places where column cube appears in row kernel.\r\n        const matrix = Array<(0 | 1)[]>(rows.length)\r\n            .fill([])\r\n            .map(() => Array<0 | 1>(columns.length).fill(0));\r\n        for (const [col, kernelCube] of columns.entries()) {\r\n            for (const [row, coKernel] of rows.entries()) {\r\n                if (coKernel.kernel.some((kCube) => kCube.equals(kernelCube))) {\r\n                    matrix[row][col] = 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Again look at the lecture presentation here.\r\n        const rowWeight = (row: number) => rows[row].coKernel.numSetBits + 1;\r\n        const colWeight = (col: number) => columns[col].numSetBits;\r\n        const value = (col: number, row: number) =>\r\n            rows[row].coKernel.or(columns[col]).numSetBits;\r\n\r\n        const literalsSaved = (rectRows: number[], rectCols: number[]) =>\r\n            _.sumBy(rectRows, (row) =>\r\n                _.sumBy(rectCols, (col) =>\r\n                    matrix[row][col] ? value(col, row) : 0,\r\n                ),\r\n            ) -\r\n            _.sumBy(rectRows, rowWeight) -\r\n            _.sumBy(rectCols, colWeight);\r\n\r\n        // This is the thesis algorithm for enumerating all prime rectangles.\r\n        // Theoretically the algorithm is branch-and-bound, but our problems\r\n        // are small enough for branch to be enough.\r\n        const allRects: [number[], number[]][] = [];\r\n        genRectangles(\r\n            rows.map((_val, idx) => idx),\r\n            columns.map((_val, idx) => idx),\r\n            matrix,\r\n            (rows, cols) => {\r\n                allRects.push([rows, cols]);\r\n                // No bound.\r\n                return true;\r\n            },\r\n        );\r\n\r\n        if (allRects.length) {\r\n            const [, rectCols] = _.maxBy(allRects, ([rows, cols]) =>\r\n                literalsSaved(rows, cols),\r\n            )!;\r\n\r\n            const divisor = rectCols.map((col) => columns[col]);\r\n            // console.log('would extract:', divisor.map((val) => [...val.iter()].map((bit) => logic.allItems[bit]).join('&')).join(' + '));\r\n            // console.log('original expression:', conjunctions.map((val) => [...val.iter()].map((bit) => logic.allItems[bit]).join('&')).join(' + '));\r\n            // const divTimer = performance.now();\r\n            const { quotient, remainder } = algebraicDivision(\r\n                conjunctions,\r\n                divisor,\r\n            );\r\n            // console.log(`algebraic division took`, performance.now() - divTimer, 'ms');\r\n\r\n            // Recursively simplify the quotient, divisor and remainder (divisor probably doesn't need to be...)\r\n\r\n            const optQuotient = new LogicalExpression(\r\n                quotient,\r\n            ).removeDuplicates();\r\n            const andTerms: Item[] = [...commonFactors].map(\r\n                (f) => logic.allItems[f],\r\n            );\r\n            const product = BooleanExpression.and(\r\n                dnfToRequirementExpr(logic, optQuotient.conjunctions),\r\n                dnfToRequirementExpr(logic, divisor),\r\n            );\r\n            const sum = BooleanExpression.or(\r\n                product,\r\n                dnfToRequirementExpr(logic, remainder),\r\n            );\r\n\r\n            // CommonFactor1 and CommonFactor2 and (Quotient and Divisor or Remainder)\r\n            return BooleanExpression.and(...andTerms, sum).simplify(\r\n                simplifier(logic),\r\n            );\r\n        }\r\n    }\r\n\r\n    // CommonFactor1 and CommonFactor2 and (SOPWithoutCommonFactors)\r\n    return BooleanExpression.and(\r\n        ...[...commonFactors].map((i) => logic.allItems[i]),\r\n        BooleanExpression.or(\r\n            ...conjunctions.map((c) => bitVecToRequirements(logic, c)),\r\n        ),\r\n    ).simplify(simplifier(logic));\r\n}\r\n\r\nfunction genRectangles(\r\n    allRows: number[],\r\n    allCols: number[],\r\n    matrix: (0 | 1)[][],\r\n    callback: (rows: number[], cols: number[]) => boolean,\r\n) {\r\n    // Trivial rectangles are rectangles of height 1 or width 1.\r\n    // A trivial row rectangle is *prime* if no other row\r\n    // has ones everywhere we have ones. Expressed differently:\r\n    // We're prime if there is no such other row that for every column,\r\n    // \"our row has a 1\" implies \"other row has a 1\" (and by A=>B <=> Bv!A)\r\n    for (const row of allRows) {\r\n        const ones = allCols.filter((col) => matrix[row][col]);\r\n        if (\r\n            ones.length &&\r\n            !allRows.some(\r\n                (otherRow) =>\r\n                    otherRow !== row &&\r\n                    allCols.every(\r\n                        (otherCol) =>\r\n                            !ones.includes(otherCol) ||\r\n                            matrix[otherRow][otherCol],\r\n                    ),\r\n            )\r\n        ) {\r\n            callback([row], ones);\r\n        }\r\n    }\r\n\r\n    for (const col of allCols) {\r\n        const ones = allRows.filter((row) => matrix[row][col]);\r\n        if (\r\n            ones.length &&\r\n            !allCols.some(\r\n                (otherCol) =>\r\n                    otherCol !== col &&\r\n                    allRows.every(\r\n                        (otherRow) =>\r\n                            !ones.includes(otherRow) ||\r\n                            matrix[otherRow][otherCol],\r\n                    ),\r\n            )\r\n        ) {\r\n            callback(ones, [col]);\r\n        }\r\n    }\r\n    genRectanglesRecursive(allRows, allCols, matrix, 0, [], [], callback);\r\n}\r\n\r\nfunction genRectanglesRecursive(\r\n    allRows: number[],\r\n    allCols: number[],\r\n    matrix: (0 | 1)[][],\r\n    index: number,\r\n    // The paper doesn't use this?\r\n    _rectRows: number[],\r\n    rectCols: number[],\r\n    callback: (rows: number[], cols: number[]) => boolean,\r\n) {\r\n    for (const c of allCols) {\r\n        if (c >= index && allRows.filter((row) => matrix[row][c]).length >= 2) {\r\n            // create M1 with rows 0 where c is 0 and rows intact where c is 1\r\n            const m1 = matrix.map((row, rowIndex) =>\r\n                matrix[rowIndex][c] ? row.slice() : row.map(() => 0 as const),\r\n            );\r\n            const rect1Rows = allRows.filter((row) => matrix[row][c]);\r\n            const rect1Cols = rectCols.slice();\r\n\r\n            let prune = false;\r\n            for (const c1 of allCols) {\r\n                if (\r\n                    allRows.filter((row) => m1[row][c1]).length ===\r\n                    allRows.filter((row) => matrix[row][c]).length\r\n                ) {\r\n                    if (c1 < c) {\r\n                        prune = true;\r\n                        break;\r\n                    } else {\r\n                        rect1Cols.push(c1);\r\n                        for (const row of allRows) {\r\n                            m1[row][c1] = 0;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!prune) {\r\n                const bound = callback(rect1Rows, rect1Cols);\r\n                if (!bound) {\r\n                    genRectanglesRecursive(\r\n                        allRows,\r\n                        allCols,\r\n                        m1,\r\n                        c,\r\n                        rect1Rows,\r\n                        rect1Cols,\r\n                        callback,\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction findKernels(\r\n    cubes: BitVector[],\r\n    variables: number[],\r\n    coKernelPath: BitVector,\r\n    seenCoKernels: BitVector[] = [],\r\n    minIdx = 0,\r\n): { kernel: BitVector[]; coKernel: BitVector }[] {\r\n    const kernels = [];\r\n    for (const [idx, bit] of variables.entries()) {\r\n        if (idx < minIdx) {\r\n            continue;\r\n        }\r\n        const s = cubes.filter((c) => c.test(bit));\r\n        if (s.length >= 2) {\r\n            const co = s.reduce((acc, c) => acc.and(c), s[0]);\r\n            const subPath = coKernelPath.or(co);\r\n            const quot = algebraicDivision(cubes, [co]).quotient;\r\n            const subKernels = findKernels(\r\n                quot,\r\n                variables,\r\n                subPath,\r\n                seenCoKernels,\r\n                idx + 1,\r\n            );\r\n            for (const sub of subKernels) {\r\n                if (\r\n                    !seenCoKernels.some((seenCo) => seenCo.equals(sub.coKernel))\r\n                ) {\r\n                    seenCoKernels.push(sub.coKernel);\r\n                    kernels.push(sub);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!seenCoKernels.some((seenCo) => seenCo.equals(coKernelPath))) {\r\n        kernels.push({\r\n            kernel: cubes,\r\n            coKernel: coKernelPath.clone(),\r\n        });\r\n    }\r\n\r\n    return kernels;\r\n}\r\n\r\nfunction algebraicDivision(\r\n    expr: BitVector[],\r\n    divisor: BitVector[],\r\n): { quotient: BitVector[]; remainder: BitVector[] } {\r\n    let quotient: BitVector[] | undefined;\r\n    for (const divCube of divisor) {\r\n        const c = expr\r\n            .filter((c) => divCube.isSubsetOf(c))\r\n            .map((c) => c.clone());\r\n        if (c.length === 0) {\r\n            return { quotient: [], remainder: expr };\r\n        }\r\n        for (const ci of c) {\r\n            for (const bit of divCube.iter()) {\r\n                ci.clearBit(bit);\r\n            }\r\n        }\r\n        if (!quotient) {\r\n            quotient = c;\r\n        } else {\r\n            quotient = quotient.filter((qc) => c.some((cc) => cc.equals(qc)));\r\n        }\r\n    }\r\n\r\n    const qd = new LogicalExpression(quotient!)\r\n        .and(new LogicalExpression(divisor))\r\n        .removeDuplicates();\r\n    const remainder = expr.filter(\r\n        (e) => !qd.conjunctions.some((qd) => qd.isSubsetOf(e)),\r\n    );\r\n    return { quotient: quotient!, remainder };\r\n}\r\n\r\nfunction bitVecToRequirements(\r\n    logic: LeanLogic,\r\n    vec: BitVector,\r\n): BooleanExpression {\r\n    return BooleanExpression.and(\r\n        ...[...vec.iter()].map((x) => logic.allItems[x]),\r\n    );\r\n}\r\n","import { BitVector } from '../../logic/bitlogic/BitVector';\r\nimport { LogicalExpression } from '../../logic/bitlogic/LogicalExpression';\r\nimport BooleanExpression, {\r\n    Item,\r\n    Op,\r\n} from '../../logic/booleanlogic/BooleanExpression';\r\nimport { SerializedBooleanExpression, SerializedItem } from './Types';\r\n\r\nexport function deserializeLogicalExpression(\r\n    expr: number[][],\r\n): LogicalExpression {\r\n    const terms = [];\r\n    for (const conj of expr) {\r\n        const vec = new BitVector();\r\n        for (const bit of conj) {\r\n            vec.setBit(bit);\r\n        }\r\n        terms.push(vec);\r\n    }\r\n    return new LogicalExpression(terms);\r\n}\r\n\r\nexport function serializeLogicalExpression(\r\n    expr: LogicalExpression,\r\n): number[][] {\r\n    return expr.conjunctions.map((c) => [...c.iter()]);\r\n}\r\n\r\nexport function serializeBooleanExpression(\r\n    expr: BooleanExpression,\r\n): SerializedBooleanExpression {\r\n    return serializeBooleanItem(expr) as SerializedBooleanExpression;\r\n}\r\n\r\nfunction serializeBooleanItem(item: Item): SerializedItem {\r\n    if (BooleanExpression.isExpression(item)) {\r\n        switch (item.type) {\r\n            case Op.And:\r\n                return {\r\n                    type: 'and',\r\n                    items: item.items.map(serializeBooleanItem),\r\n                };\r\n            case Op.Or:\r\n                return {\r\n                    type: 'or',\r\n                    items: item.items.map(serializeBooleanItem),\r\n                };\r\n        }\r\n    } else {\r\n        return item;\r\n    }\r\n}\r\n\r\nexport function deserializeBooleanExpression(\r\n    expr: SerializedBooleanExpression,\r\n): BooleanExpression {\r\n    return new BooleanExpression(\r\n        expr.items.map((i) =>\r\n            typeof i === 'string' ? i : deserializeBooleanExpression(i),\r\n        ),\r\n        expr.type === 'and' ? Op.And : Op.Or,\r\n    );\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [361], function() { return __webpack_require__(5221); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"2b022c30\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t221: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunksshd_randomizer_tracker\"] = self[\"webpackChunksshd_randomizer_tracker\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(361).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["ONE","BigInt","ZERO","BitVector","bits","intSet","data","this","Set","bit","add","has","delete","other","a","b","size","tmp","filter","v","intersection","numSetBits","domainSize","str","Boolean","values","next","value","LogicalExpression","conjs","conjunctions","andToDnf2","isTriviallyFalse","false","drop","unless","map","c","test","clone","clearBit","terms","candidate","i","findIndex","t","isSubsetOf","strongerTerm","push","length","vec","some","isEmpty","left","right","newExpr","l","r","or","findNewSubgoals","opaqueBits","requirements","idx","learnedExpressions","visitedExpressions","expr","conj","iter","moreBits","setBit","computeGroundExpression","result","nextConj","tmpExpr","conjOpaqueBits","and","newTerm","removeDuplicates","logic","entries","unifyRequirements","unificationCandidates","getSingleSetBit","simplified","targetList","tryUnifyEquivalent","implA","implB","bImpliesAIndex","cA","cB","implACon","slice","bReqVec","splice","cn","shallowSimplify","inliningCandidates","item","intersects","newItems","skip","reqItem","revealed","isTriviallyTrue","Op","g","BooleanExpression","items","type","And","Or","andInitialValue","andReducer","orInitialValue","orReducer","reducerArguments","accumulator","isExpression","reduce","isReduced","isAnd","_","acc","isOr","Error","isItemTrue","implies","iterations","updatedExpression","flatten","removeDuplicateChildren","removeDuplicateExpressions","shiftWeakerTermsUp","otherExpression","areItemsEqual","difference","otherItem","isEqualTo","flatMap","flatItem","firstItem","parentItems","objectValue","sourceValue","updatedParentItems","getUpdatedParentItems","sameTypeItems","oppositeTypeItems","oppositeType","removeSelf","forEach","removeDuplicateChildrenHelper","childExpression","expression","removeParent","itemIsSubsumed","createFlatExpression","removeIfIdentical","expressionType","every","isSubsumedBy","index","expressionIsSubsumed","otherIndex","parentExpression","removeDuplicateExpressionsInChildren","commonFactors","booleanItems","includes","subItem","console","log","itemsCollection","deserializeLogicalExpression","serializeBooleanExpression","serializeBooleanItem","simplifier","dominators","dnfToRequirementExpr","sop","x","allItems","simplify","dominator","dominatorBit","itemBits","variables","kernels","findKernels","k","coKernel","columns","kernel","kCube","cube","equals","rows","matrix","Array","fill","col","kernelCube","row","rowWeight","colWeight","literalsSaved","rectRows","rectCols","allRects","allRows","allCols","callback","ones","otherRow","otherCol","genRectanglesRecursive","genRectangles","_val","cols","divisor","algebraicDivision","quotient","remainder","optQuotient","andTerms","f","product","sum","bitVecToRequirements","_rectRows","m1","rowIndex","rect1Rows","rect1Cols","prune","c1","cubes","coKernelPath","seenCoKernels","minIdx","s","co","subPath","subKernels","sub","seenCo","divCube","ci","qc","cc","qd","e","onmessage","ev","start","performance","now","learned","checkId","numLearnedInPrecomputation","potentialPath","precomputeBit","opaqueOnlyExpr","simplifyStart","analyze","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","id","loaded","__webpack_modules__","call","m","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","Object","keys","key","n","getter","__esModule","d","definition","o","defineProperty","enumerable","get","chunkId","Promise","all","promises","u","miniCssF","globalThis","Function","window","obj","prop","prototype","hasOwnProperty","nmd","paths","children","p","installedChunks","importScripts","chunkLoadingGlobal","self","parentChunkLoadingFunction","bind","moreModules","runtime","pop","then"],"sourceRoot":""}